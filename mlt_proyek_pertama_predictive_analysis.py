# -*- coding: utf-8 -*-
"""MLT Proyek Pertama - Predictive Analysis

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jLTYc2DwaTQHv980x6QgW2B6r7w7vYfh

# Telco Customer Churn Analysis and Prediction

## Import Library
"""

# Data Load and Exploration Data
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from google.colab import files

# Data Preprocessing
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

# Machine Learning Models (Classification Problem)
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier, GradientBoostingClassifier
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score, f1_score, precision_score, recall_score

# Warnings
import warnings
warnings.filterwarnings("ignore")

"""## Data Loading and Exploration Data"""

files.upload()
df = pd.read_csv('Telco-Customer-Churn.csv')
df.head()

df.info()

churn_df = df.copy()

"""### Statistik Deskriptif"""

# Menghitung statistik deskriptif pada kolom bertipe data numerik
churn_df[['Tenure', 'MonthlyCharges', 'TotalCharges']].describe().round(2)

# Hitung total dan persentase churn
churn_summary = churn_df['Churn'].value_counts().to_frame(name='Total')
churn_summary['Percentage'] = (churn_summary['Total'] / churn_summary['Total'].sum()) * 100

# Tampilkan hasil
churn_summary.round(2)

"""### Mengubah Nama Kolom dan Tipe Data"""

# Merubah nama kolom
churn_df.rename(columns={'gender': 'Gender'}, inplace=True)
churn_df.rename(columns={'tenure': 'Tenure'}, inplace=True)
churn_df['SeniorCitizen'] = churn_df['SeniorCitizen'].map({0: 'No', 1: 'Yes'})

# Mengubah beberapa kolom menjadi tipe kategori
categorical_column = [
    'Gender', 'SeniorCitizen', 'Partner', 'Dependents', 'PhoneService',
    'MultipleLines', 'InternetService', 'OnlineSecurity', 'OnlineBackup',
    'DeviceProtection', 'TechSupport', 'StreamingTV', 'StreamingMovies',
    'Contract', 'PaperlessBilling', 'PaymentMethod', 'Churn'
]
for column in categorical_column:
    churn_df[column] = churn_df[column].astype('category')

churn_df.info()

"""### Mengecek Missing Value"""

churn_df.isnull().sum()

"""## Data Preprocessing

### Handling Missing Value
"""

# Menghitung jumlah nilai kosong/spasi di setiap kolom
jumlah_kosong = churn_df.apply(lambda col: col.apply(lambda x: isinstance(x, str) and x.strip() == '').sum())
print("Jumlah nilai kosong/berisi spasi per kolom:\n", jumlah_kosong)

# Menampilkan baris-baris yang mengandung nilai kosong atau hanya berisi spasi
mask_kosong = churn_df.map(lambda x: isinstance(x, str) and x.strip() == '')
baris_kosong = churn_df[mask_kosong.any(axis=1)]
print("\nBaris yang mengandung nilai kosong atau hanya spasi:\n", baris_kosong)

# Mengonversi kolom 'TotalCharges' menjadi tipe numerik
churn_df['TotalCharges'] = pd.to_numeric(churn_df['TotalCharges'], errors='coerce')

# Mengisi nilai NaN pada 'TotalCharges' dengan 0
churn_df['TotalCharges'] = churn_df['TotalCharges'].fillna(0)

# Mengubah 'TotalCharges' menjadi tipe float
churn_df['TotalCharges'] = churn_df['TotalCharges'].astype('float')

churn_df.info()

"""### Data Splitting"""

# Memisahkan fitur (X) dan target (y)
X = churn_df.drop(columns=['customerID', 'Churn'])
y = churn_df['Churn'].map({'Yes': 1, 'No': 0})

# One-hot encoding untuk fitur kategorikal
X = pd.get_dummies(X)

# Simpan nama kolom
X_columns = X.columns

# Normalisasi fitur numerik
numerical_features = X.select_dtypes(include=['int64', 'float64']).columns

scaler = StandardScaler()
X[numerical_features] = scaler.fit_transform(X[numerical_features])
X[numerical_features].head()

print("Cek tipe data sebelum split:")
print(X.dtypes)

# Membagi dataset menjadi training dan testing
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Menghitung panjang/jumlah data
print("Jumlah data: ",len(X))
# Menghitung panjang/jumlah data pada x_test
print("Jumlah data latih: ",len(X_train))
# Menghitung panjang/jumlah data pada x_test
print("Jumlah data test: ",len(X_test))

"""## Data Visualization

### Multivariate Analysis: Categorical Features vs. Churn
"""

# Atur gaya dan palet warna
sns.set(style="whitegrid")
palette = sns.color_palette("Set2")

# Kolom kategorikal kecuali 'Churn'
categorical_columns = churn_df.select_dtypes(include='category').columns.drop('Churn')

# Hitung jumlah plot
n = len(categorical_columns)
cols = 2  # 2 plot per baris
rows = (n + 1) // cols  # Hitung jumlah baris yang diperlukan

plt.figure(figsize=(14, 6 * rows))

for i, col in enumerate(categorical_columns, 1):
    plt.subplot(rows, cols, i)
    ax = sns.countplot(data=churn_df, x=col, hue="Churn", palette=palette)

    # Tambahkan anotasi jumlah pada batang
    for p in ax.patches:
        count = int(p.get_height())
        if count > 0:
            x = p.get_x() + p.get_width() / 2
            y = p.get_height() * 0.5 + 5
            ax.annotate(f'{count}', (x, y), ha='center', va='center',
                        fontsize=10, fontweight='bold', color='black')

    plt.title(f"Distribusi Churn berdasarkan {col}", fontsize=13, fontweight='bold')
    plt.xlabel(col, fontsize=11)
    plt.ylabel("Jumlah", fontsize=11)
    plt.xticks(rotation=45)
    plt.legend(title="Churn", loc='upper right')

plt.tight_layout()
plt.show()

"""#### Insight
Untuk mengeksplorasi bagaimana berbagai fitur kategorikal memengaruhi customer churn, berdasarkan visualisasi distribusi jumlah.
1. Gender
  - Tingkat churn hampir sama di seluruh gender.
  - **Insight:** Gender tidak terlalu memengaruhi churn.
2. SeniorCitizen
  - Senior citizen memiliki tingkat churn lebih tinggi dibandingkan non-senior.
  - **Insight:** Pelanggan yang lebih tua cenderung lebih mungkin berhenti berlangganan.
3. Partner
  - Pelanggan tanpa partner cenderung lebih sering churn.
  - **Insight:** Tinggal bersama partner mungkin berkontribusi terhadap stabilitas pelanggan.
4. Dependents
  - Mereka yang tidak memiliki dependents lebih sering churn.
  - **Insight:** Pelanggan dengan tanggungan mungkin memiliki kebutuhan layanan yang lebih konsisten.
5. PhoneServuce
  - Sebagian besar pelanggan memiliki phone service.
  - Churn secara proporsional lebih rendah pada mereka yang tidak memiliki phone service.
  - **Insight:** Phone service sendiri bukan pendorong utama churn
6. MultipleLines
  - Sedikit lebih banyak churn terjadi pada pelanggan dengan multiple lines.
  - **Insight:** Mengelola beberapa jalur mungkin menambah ketidakpuasan.
7. InternetService
  - Pengguna fiber optic memiliki tingkat churn tertinggi.
  - Pengguna DSL churn lebih sedikit, dan yang tidak memiliki internet churn paling rendah.
  - **Insight:** Pengguna fiber mungkin memiliki ekspektasi lebih tinggi atau ketidakpuasan terhadap harga.
8. Online Services (Security, Backup, Device Protection, Tech Support)
  - Pelanggan tanpa layanan online churn secara signifikan lebih tinggi.
  - **Insight:** Value-added services dapat mengurangi churn.
  - **Action:** Tawarkan layanan ini untuk meningkatkan retensi.
9. Streaming Services (TV & Movies)
  - Churn lebih tinggi pada mereka yang tidak menggunakan streaming services.
  - **Insight:** Keterlibatan hiburan berkorelasi dengan retensi pelanggan.
10. Contract Type
  - Month-to-month contracts memiliki tingkat churn yang sangat tinggi.
  - Two-year contracts memiliki churn terendah.
  - **Insight:** Long-term contracts secara signifikan mengurangi churn.
  - **Action:** Tawarkan insentif untuk peningkatan kontrak.
11. Paperless Billing
  - Churn lebih tinggi pada pelanggan dengan paperless billing.
  - I**nsight:** Kemungkinan terkait dengan pengguna yang melek digital dan sering membandingkan dengan pesaing.
12. Payment Method
  - Tingkat churn tertinggi pada pengguna Electronic Check.
  - Churn terendah pada pengguna Credit Card, Mailed Check, atau Bank Transfers.
  - **Insight:** Hambatan dalam metode pembayaran dapat meningkatkan churn.

### Churn Analysis Based on Key Numerical Features
"""

# Pilih hanya kolom numerik dari DataFrame
numerical_columns = churn_df.select_dtypes(include=['int64', 'float64'])

# Atur gaya tampilan visualisasi
sns.set(style="whitegrid")
palette = sns.color_palette("Set2")

# Buat subplot: 1 baris, 3 kolom
plt.figure(figsize=(18, 5))

for i, feature in enumerate(numerical_columns, 1):
    plt.subplot(1, 3, i)
    sns.boxplot(data=churn_df, x='Churn', y=feature, palette=palette)
    plt.title(f'{feature} vs Churn', fontsize=13, fontweight='bold')
    plt.xlabel("Churn")
    plt.ylabel(feature)

plt.tight_layout()
plt.show()

"""#### Insight
1. Tenure vs Churn
  - Observation: Pelanggan yang churn (Ya) cenderung memiliki masa berlangganan (tenure) yang lebih pendek dengan perusahaan.
  - Insight: Median tenure untuk pelanggan yang churn secara signifikan lebih rendah dibanding yang tidak churn.
  - Interpretation: Churn lebih umum terjadi pada tahap awal siklus hidup pelanggan.
  - Actionable Recommendation:
    - Fokuskan strategi retensi pada pelanggan baru, terutama pada tahun pertama.
    - Tawarkan insentif loyalitas, panduan onboarding, dan dukungan personal sejak awal.

2. Monthly Charges vs Churn
  - Observation: Pelanggan yang churn umumnya memiliki biaya bulanan yang lebih tinggi.
  - Insight: Distribusi menunjukkan bahwa pelanggan yang churn membayar lebih mahal rata-rata dibanding yang tidak churn.
  - Interpretation: Harga yang lebih tinggi mungkin berkontribusi terhadap ketidakpuasan pelanggan.
  - Actionable Recommendation:
    - Evaluasi ulang harga untuk segmen dengan biaya tinggi.
    - Tawarkan layanan bernilai tambah atau paket diskon untuk pelanggan dengan risiko churn yang tinggi.

3. Total Charges vs Churn
  - Observation: Pelanggan yang churn memiliki total pembayaran yang lebih rendah dibanding pelanggan loyal.
  - Insight: Menunjukkan bahwa mereka churn lebih awal dalam kontrak, meskipun mungkin memiliki tarif bulanan tinggi.
  - Interpretation: Kerugian total pendapatan per pelanggan yang churn cukup besar.
  - Actionable Recommendation:
    - Kurangi churn untuk meningkatkan nilai umur pelanggan (CLV).
    - Terapkan prediksi churn secara proaktif dan lakukan intervensi lebih awal.


Kesimpulan:
- Pelanggan yang Churn = Tenure pendek + Biaya bulanan tinggi + Total pendapatan rendah.
- Strategi Utama: Fokus pada keterlibatan awal dan penyesuaian harga yang personal.

Langkah Selanjutnya:
- Gunakan machine learning untuk membangun model prediksi churn.

## Model Training
"""

# Melatih Model 1 dengan algoritma K-Nearest Neighbors (KNN)
knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(X_train, y_train)

# Melatih Model 2 dengan algoritma Random Forest
rf = RandomForestClassifier(n_estimators=100, random_state=42)
rf.fit(X_train, y_train)

# Melatih Model 3 dengan algoritma Decision Tree
dt = DecisionTreeClassifier(random_state=42)
dt.fit(X_train, y_train)

# Melatih model 4 dengan algoritma Logistic Regression
lr = LogisticRegression(random_state=42)
lr.fit(X_train, y_train)

# Melatih model 5 dengan algoritma Naive Bayes
nb = GaussianNB()
nb.fit(X_train, y_train)

# Melatih model 6 dengan algoritma SVC
svc = SVC(random_state=42)
svc.fit(X_train, y_train)

# Melatih model 7 dengan algoritma ABClassifier
ada = AdaBoostClassifier(random_state=42)
ada.fit(X_train, y_train)

# Melatih model 8 dengan algoritma GradientBoostingClassifier
gbc = GradientBoostingClassifier(random_state=42)
gbc.fit(X_train, y_train)

print(X_train.dtypes)

"""## Model Evaluation

### Akurasi, Confusion Matrix, Classification Report.
"""

# List model yang akan dievaluasi
models = {
    "K-Nearest Neighbors": knn,
    "Random Forest": rf,
    "Decision Tree": dt,
    "Logistic Regression": lr,
    "Naive Bayes": nb,
    "SVC": svc,
    "AdaBoost": ada,
    "GradientBoosting": gbc
}

# Dictionary untuk menyimpan hasil evaluasi
results = {
    "Model": [],
    "Accuracy": [],
    "F1-Score": [],
    "Precision": [],
    "Recall": []
}

# Lakukan prediksi pada data uji dan evaluasi setiap model
for name, model in models.items():
    y_pred = model.predict(X_test)

    # Hitung metrik evaluasi
    accuracy = accuracy_score(y_test, y_pred)
    f1 = f1_score(y_test, y_pred, average='weighted')
    precision = precision_score(y_test, y_pred, average='weighted')
    recall = recall_score(y_test, y_pred, average='weighted')

    # Print hasil evaluasi
    print(f"Evaluasi Model: {name}")
    print(f"Accuracy: {accuracy:.4f}")
    print(f"F1-Score: {f1:.4f}")
    print(f"Precision: {precision:.4f}")
    print(f"Recall: {recall:.4f}")
    print("\nClassification Report:\n", classification_report(y_test, y_pred))

    # Buat Confusion Matrix
    cm = confusion_matrix(y_test, y_pred)
    plt.figure(figsize=(5, 4))
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=model.classes_, yticklabels=model.classes_)
    plt.xlabel("Predicted")
    plt.ylabel("Actual")
    plt.title(f"Confusion Matrix - {name}")
    plt.show()
    print("\n")

    # Simpan hasil ke dalam dictionary
    results["Model"].append(name)
    results["Accuracy"].append(accuracy)
    results["F1-Score"].append(f1)
    results["Precision"].append(precision)
    results["Recall"].append(recall)

# Ubah dictionary menjadi DataFrame dan urutkan berdasarkan Accuracy
results_df = pd.DataFrame(results)
results_df = results_df.sort_values(by="Accuracy", ascending=False).reset_index(drop=True)

print("Evaluasi Model - Diurutkan berdasarkan Akurasi:")
display((results_df).round(2))

"""#### Insight
Dari hasil Evaluasi Model terlihat Algoritma Logistic Regression memiliki nilai akurasi yang paling tinggi dari ke-8 model yang saya gunakan yaitu persentase mencapai 82%.

### Feature Importance
"""

# Ambil nama kolom dari data training
feature_names = X_train.columns

# Ambil koefisien dari model Logistic Regression
coefficients = lr.coef_[0]

# Buat DataFrame untuk melihat pengaruh tiap fitur
importance_df = pd.DataFrame({
    'Feature': feature_names,
    'Coefficient': coefficients,
    'AbsCoefficient': np.abs(coefficients)
})

# Urutkan berdasarkan pengaruh terbesar
top_features_lr = importance_df.sort_values(by='AbsCoefficient', ascending=False).head(5)

print("Top 5 Fitur Paling Berpengaruh (Logistic Regression):")
top_features_lr[['Feature', 'Coefficient']]

# Ambil nama fitur
feature_names = X_train.columns

# Ambil feature importance dari model
importances = rf.feature_importances_  # Misalnya model bernama rf

# Buat DataFrame
importance_df_rf = pd.DataFrame({
    'Feature': feature_names,
    'Importance': importances
})

# Urutkan berdasarkan pentingnya
top_features_rf = importance_df_rf.sort_values(by='Importance', ascending=False).head(5)

print("Top 5 Fitur Paling Berpengaruh (Random Forest):")
top_features_rf

# Ambil fitur dari kolom 'Feature' lalu ubah ke set
tf_lr = set(top_features_lr['Feature'])
tf_rf = set(top_features_rf['Feature'])

# Gabungkan fitur unik dari kedua model ke list
combined_features = list(tf_lr.union(tf_rf))

# Buat DataFrame dari list fitur tersebut
combined_df = pd.DataFrame(combined_features, columns=['Feature'])

print("Variabel-variabel yang paling berpengaruh terhadap churn:\n")
combined_df

"""#### Insight
Fitur-fitur di atas adalah variabel-variabel penting yang memengaruhi churn pelanggan berdasarkan hasil dua model berbeda.

## Inference Model
"""

# Data baru yang akan diprediksi
sample_data = pd.DataFrame({
    'gender': ['Male', 'Female', 'Female', 'Male'],
    'SeniorCitizen': [0, 0, 0, 1],
    'Partner': ['Yes', 'Yes', 'Yes', 'No'],
    'Dependents': ['No', 'Yes', 'Yes', 'No'],
    'tenure': [12, 72, 70, 1],
    'PhoneService': ['Yes', 'Yes', 'Yes', 'Yes'],
    'MultipleLines': ['No', 'Yes', 'Yes', 'No'],
    'InternetService': ['Fiber optic', 'DSL', 'DSL', 'Fiber optic'],
    'OnlineSecurity': ['No', 'Yes', 'Yes', 'No'],
    'OnlineBackup': ['Yes', 'Yes', 'Yes', 'No'],
    'DeviceProtection': ['No', 'Yes', 'Yes', 'No'],
    'TechSupport': ['No', 'Yes', 'Yes', 'No'],
    'StreamingTV': ['Yes', 'Yes', 'Yes', 'Yes'],
    'StreamingMovies': ['No', 'Yes', 'Yes', 'Yes'],
    'Contract': ['Month-to-month', 'Two year', 'Two year', 'Month-to-month'],
    'PaperlessBilling': ['Yes', 'No', 'No', 'Yes'],
    'PaymentMethod': ['Electronic check', 'Credit card (automatic)', 'Bank transfer (automatic)', 'Electronic check'],
    'MonthlyCharges': [75.5, 65.0, 55.2, 95.7],
    'TotalCharges': [900.5, 4500.0, 3800.5, 95.7]
})

# One-hot encode data baru
new_data_encoded = pd.get_dummies(sample_data)

# Reindex agar kolom sesuai dengan X_columns saat training
new_data_encoded = new_data_encoded.reindex(columns=X_columns, fill_value=0)

# Lakukan scaling hanya untuk kolom numerik
new_data_encoded[numerical_features] = scaler.transform(new_data_encoded[numerical_features])

# Prediksi semua baris
pred = lr.predict(new_data_encoded)

# Interpretasi hasil untuk semua data
for i, p in enumerate(pred):
    print(f"Data ke-{i+1} prediksi churn:", "Ya (Churn)" if p == 1 else "Tidak (Tidak Churn)")